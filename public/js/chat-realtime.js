/**
 * Chat Realtime JavaScript Module
 * 
 * Qu·∫£n l√Ω c√°c ch·ª©c nƒÉng chat realtime bao g·ªìm:
 * - G·ª≠i/nh·∫≠n tin nh·∫Øn realtime qua Laravel Echo & Pusher
 * - X·ª≠ l√Ω UI interactions (scroll, typing, file upload)
 * - ƒê·ªìng b·ªô v·ªõi Livewire components
 * - Qu·∫£n l√Ω tr·∫°ng th√°i conversation
 */

class ChatRealtime {
    constructor() {
        this.currentConversationId = null;
        this.isTyping = false;
        this.typingTimeout = null;
        this.messageContainer = null;
        this.messageInput = null;
        this.fileUploadInput = null;
        this.currentUserId = null;
        this.echoChannels = new Map();

        console.log('üí¨ ChatRealtime: Initializing...');
        this.init();
    }

    /**
     * Kh·ªüi t·∫°o chat realtime
     */
    init() {
        // ƒê·ª£i DOM s·∫µn s√†ng tr∆∞·ªõc
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                this.initializeElements();
                this.initializeEcho();
                this.bindEvents();
                this.setupLivewireListeners();
            });
        } else {
            // DOM ƒë√£ s·∫µn s√†ng
            this.initializeElements();
            this.initializeEcho();
            this.bindEvents();
            this.setupLivewireListeners();
        }

        // ƒê·ª£i Livewire s·∫µn s√†ng
        document.addEventListener('livewire:initialized', () => {
            this.setupLivewireListeners();
        });
    }

    /**
     * Kh·ªüi t·∫°o c√°c DOM elements
     */
    initializeElements() {
        // C√°c elements ch√≠nh
        this.messageContainer = document.getElementById('message-container');
        this.messageInput = document.querySelector('#messageInputField') || 
                           document.querySelector('[wire\\:model="message_content"]');
        this.fileUploadInput = document.querySelector('[wire\\:model="fileUpload"]');
        this.chatConversation = document.getElementById('chat-conversation');

        // L·∫•y conversation ID t·ª´ window ho·∫∑c DOM
        this.currentConversationId = window.currentConversationId || 
                                   document.querySelector('[data-conversation-id]')?.dataset.conversationId;

        // L·∫•y current user ID t·ª´ meta tag ho·∫∑c global variable
        const userMeta = document.querySelector('meta[name="user-id"]');
        this.currentUserId = userMeta ? userMeta.content : window.currentUserId;

    }

    /**
     * Kh·ªüi t·∫°o Laravel Echo connections
     */
    initializeEcho() {
        if (!window.Echo) {
            console.error('üí¨ ChatRealtime: Laravel Echo not available');
            return;
        }

        // console.log('üí¨ ChatRealtime: Echo is available, checking Pusher connection');
        
        // Debug Pusher connection nh∆∞ chat.js
        if (window.Echo.connector && window.Echo.connector.pusher) {
            const pusher = window.Echo.connector.pusher;
            console.log('üí¨ ChatRealtime: Pusher state:', pusher.connection.state);
            
            // Add connection event listeners for debugging
            // pusher.connection.bind('connected', () => {
            //     console.log('üí¨ ChatRealtime: Pusher connected successfully');
            // });
            
            pusher.connection.bind('disconnected', () => {
                console.log('üí¨ ChatRealtime: Pusher disconnected');
            });
            
            pusher.connection.bind('error', (error) => {
                console.error('üí¨ ChatRealtime: Pusher connection error:', error);
            });
        }

        // Setup global channels first
        this.setupGlobalChannels();

        if (!this.currentConversationId) {
            console.warn('üí¨ ChatRealtime: No conversation ID found, skipping conversation channels');
            return;
        }

        // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o Echo s·∫µn s√†ng nh∆∞ chat.js
        setTimeout(() => {
            this.setupConversationChannel(this.currentConversationId);
        }, 100);
    }

    /**
     * Thi·∫øt l·∫≠p channel cho conversation c·ª• th·ªÉ
     */
    setupConversationChannel(conversationId) {
        if (!conversationId) return;

        // H·ªßy channel c≈© n·∫øu c√≥
        this.leaveConversationChannel();

        const channels = [
            `conversations.${conversationId}`,
            `bookbee.${conversationId}`
        ];

        channels.forEach(channelName => {
            try {
                // console.log(`üí¨ ChatRealtime: Setting up channel ${channelName}`);
                const channel = window.Echo.channel(channelName);
                
                // IMPORTANT: Listen BEFORE subscription callbacks
                channel.listen('MessageSent', (data) => {
                    console.log('üí¨ ChatRealtime: Received MessageSent via Echo', {
                        channel: channelName,
                        messageId: data.id,
                        senderId: data.sender_id,
                        currentUserId: this.currentUserId,
                        data: data
                    });
                    
                    this.handleIncomingMessage(data);
                });

                channel.listen('UserTyping', (data) => {
                    console.log('üí¨ ChatRealtime: Received UserTyping', data);
                    this.handleTypingIndicator(data);
                });

                // ƒêƒÉng k√Ω callback cho subscription_succeeded SAU khi ƒë√£ listen
                channel.subscribed(() => {
                    console.log(`üí¨ ChatRealtime: Successfully subscribed to ${channelName}`);
                });

                // ƒêƒÉng k√Ω callback cho subscription_error
                channel.error((error) => {
                    console.error(`üí¨ ChatRealtime: Subscription error for ${channelName}:`, error);
                });

                // BACKUP: Direct Pusher binding nh∆∞ chat.js ƒë·ªÉ ƒë·∫£m b·∫£o callback ƒë∆∞·ª£c ƒëƒÉng k√Ω
                if (window.Echo.connector && window.Echo.connector.pusher) {
                    const pusher = window.Echo.connector.pusher;
                    const pusherChannel = pusher.subscribe(channelName);
                    
                    pusherChannel.bind('MessageSent', (data) => {
                        // console.log('üí¨ ChatRealtime: Received MessageSent via direct Pusher', {
                        //     channel: channelName,
                        //     data: data
                        // });
                        this.handleIncomingMessage(data);
                    });

                    // pusherChannel.bind('pusher:subscription_succeeded', () => {
                    //     console.log(`üí¨ ChatRealtime: Direct Pusher subscription successful for ${channelName}`);
                    // });
                }

                this.echoChannels.set(channelName, channel);
                // console.log(`üí¨ ChatRealtime: Channel ${channelName} setup completed`);

            } catch (error) {
                console.error(`üí¨ ChatRealtime: Error subscribing to ${channelName}:`, error);
            }
        });

        this.currentConversationId = conversationId;
    }

    /**
     * Thi·∫øt l·∫≠p c√°c channel global
     */
    setupGlobalChannels() {
        // Channel cho user status
        try {
            // console.log('üí¨ ChatRealtime: Setting up user-status channel');
            const userStatusChannel = window.Echo.channel('user-status');
            
            userStatusChannel.listen('UserSessionChanged', (data) => {
                console.log('üí¨ ChatRealtime: Received UserSessionChanged', data);
                this.handleUserStatusChange(data);
            });
            
            this.echoChannels.set('user-status', userStatusChannel);
            console.log('üí¨ ChatRealtime: User-status channel setup completed');
        } catch (error) {
            console.error('üí¨ ChatRealtime: Error setting up user-status channel:', error);
        }

        // Channel global cho bookbee v·ªõi backup Pusher binding
        try {
            // console.log('üí¨ ChatRealtime: Setting up bookbee.global channel');
            const globalChannel = window.Echo.channel('bookbee.global');
            
            globalChannel.listen('MessageSent', (data) => {
                console.log('üí¨ ChatRealtime: Received MessageSent on global channel via Echo', data);
                this.handleGlobalMessageUpdate(data);
            });

            // BACKUP: Direct Pusher binding cho global channel
            if (window.Echo.connector && window.Echo.connector.pusher) {
                const pusher = window.Echo.connector.pusher;
                const pusherGlobalChannel = pusher.subscribe('bookbee.global');
                
                pusherGlobalChannel.bind('MessageSent', (data) => {
                    // console.log('üí¨ ChatRealtime: Received MessageSent on global channel via direct Pusher', data);
                    this.handleGlobalMessageUpdate(data);
                });

                pusherGlobalChannel.bind('pusher:subscription_succeeded', () => {
                    console.log('üí¨ ChatRealtime: Direct Pusher subscription successful for bookbee.global');
                });
            }
            
            this.echoChannels.set('bookbee.global', globalChannel);
            // console.log('üí¨ ChatRealtime: Global channel setup completed');
        } catch (error) {
            console.error('üí¨ ChatRealtime: Error setting up global channel:', error);
        }
    }

    /**
     * R·ªùi kh·ªèi conversation channel hi·ªán t·∫°i
     */
    leaveConversationChannel() {
        if (this.currentConversationId) {
            const channels = [
                `conversations.${this.currentConversationId}`,
                `bookbee.${this.currentConversationId}`
            ];

            channels.forEach(channelName => {
                const channel = this.echoChannels.get(channelName);
                if (channel) {
                    try {
                        window.Echo.leave(channelName);
                        this.echoChannels.delete(channelName);
                        console.log(`üí¨ ChatRealtime: Left channel ${channelName}`);
                    } catch (error) {
                        console.error(`üí¨ ChatRealtime: Error leaving ${channelName}:`, error);
                    }
                }
            });
        }
    }

    /**
     * X·ª≠ l√Ω tin nh·∫Øn ƒë·∫øn
     */
    handleIncomingMessage(data) {
        console.log('üí¨ ChatRealtime: Processing incoming message', {
            messageId: data.id,
            senderId: data.sender_id,
            currentUserId: this.currentUserId,
            conversationId: data.conversation_id,
            content: data.content?.substring(0, 50) + '...'
        });

        // B·ªè qua tin nh·∫Øn t·ª´ ch√≠nh m√¨nh
        if (data.sender_id && data.sender_id == this.currentUserId) {
            console.log('üí¨ ChatRealtime: Skipping own message');
            return;
        }

        // B·ªè qua n·∫øu kh√¥ng ph·∫£i conversation hi·ªán t·∫°i
        if (data.conversation_id && data.conversation_id != this.currentConversationId) {
            // console.log('üí¨ ChatRealtime: Message for different conversation, refreshing list only');
            // Ch·ªâ refresh conversation list
            this.refreshConversationList();
            return;
        }

        // console.log('üí¨ ChatRealtime: Processing message for current conversation');

        // Th√¥ng b√°o cho Livewire component ƒë·ªÉ refresh (quan tr·ªçng!)
        if (window.Livewire) {
            try {
                // T√¨m component ChatRealtime v√† g·ªçi method handleIncomingMessage
                const component = window.Livewire.find(this.findChatRealtimeComponentId());
                if (component) {
                    console.log('üí¨ ChatRealtime: Calling Livewire handleIncomingMessage');
                    component.call('handleIncomingMessage', data);
                } else {
                    // Fallback: dispatch event
                    console.log('üí¨ ChatRealtime: Using fallback dispatch');
                    window.Livewire.dispatch('handleIncomingMessage', { payload: data });
                }
            } catch (error) {
                console.error('üí¨ ChatRealtime: Error notifying Livewire:', error);
            }
        }

        // Scroll to bottom sau khi Livewire update (quan tr·ªçng ƒë·ªÉ timing ƒë√∫ng!)
        setTimeout(() => {
            // console.log('üí¨ ChatRealtime: Scrolling after incoming message');
            this.scrollToBottom();
            this.showMessageNotification(data);
        }, 100); // Gi·∫£m delay xu·ªëng ƒë·ªÉ responsive h∆°n
    }

    /**
     * X·ª≠ l√Ω typing indicator
     */
    handleTypingIndicator(data) {
        if (data.user_id == this.currentUserId) return;

        const typingIndicator = document.getElementById('typing-indicator');
        if (!typingIndicator) return;

        if (data.is_typing) {
            typingIndicator.style.display = 'block';
            typingIndicator.innerHTML = `
                <div class="d-flex align-items-center">
                    <div class="avatar-sm me-2">
                        <div class="avatar-title bg-light rounded-circle">
                            ${data.user_name ? data.user_name.charAt(0).toUpperCase() : 'U'}
                        </div>
                    </div>
                    <div class="typing-animation">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </div>
                    <small class="text-muted ms-2">${data.user_name || 'Someone'} ƒëang nh·∫≠p...</small>
                </div>
            `;
            this.scrollToBottom();
        } else {
            typingIndicator.style.display = 'none';
        }
    }

    /**
     * X·ª≠ l√Ω thay ƒë·ªïi tr·∫°ng th√°i user
     */
    handleUserStatusChange(data) {
        // console.log('üí¨ ChatRealtime: User status changed', data);
        
        // Show toast notification
        if (data.message && data.type) {
            this.showToast(data.message, data.type);
        }

        // Update UI elements n·∫øu c·∫ßn
        this.updateUserStatus(data.user);
    }

    /**
     * X·ª≠ l√Ω c·∫≠p nh·∫≠t tin nh·∫Øn global
     */
    handleGlobalMessageUpdate(data) {
        // Ch·ªâ refresh conversation list, kh√¥ng c·∫ßn th√™m tin nh·∫Øn
        this.refreshConversationList();
    }

    /**
     * Bind c√°c events cho UI
     */
    bindEvents() {
        // Enter key ƒë·ªÉ g·ª≠i tin nh·∫Øn
        if (this.messageInput) {
            this.messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                } else if (e.key === 'Enter' && e.shiftKey) {
                    // Cho ph√©p xu·ªëng d√≤ng v·ªõi Shift+Enter
                    return;
                } else {
                    // Trigger typing indicator
                    this.handleTyping();
                }
            });

            // Handle paste events (cho vi·ªác paste h√¨nh ·∫£nh)
            this.messageInput.addEventListener('paste', (e) => {
                this.handlePaste(e);
            });
        }

        // File upload events
        if (this.fileUploadInput) {
            this.fileUploadInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    this.handleFileUpload(e.target.files[0]);
                }
            });
        }

        // Drag and drop cho file upload
        if (this.chatConversation) {
            this.chatConversation.addEventListener('dragover', (e) => {
                e.preventDefault();
                this.chatConversation.classList.add('drag-over');
            });

            this.chatConversation.addEventListener('dragleave', (e) => {
                e.preventDefault();
                this.chatConversation.classList.remove('drag-over');
            });

            this.chatConversation.addEventListener('drop', (e) => {
                e.preventDefault();
                this.chatConversation.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.handleFileUpload(files[0]);
                }
            });
        }

        // Copy message events
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('copy-message')) {
                this.copyMessage(e.target.dataset.message);
            }
        });

        // Image modal events
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('message-image')) {
                this.showImageModal(e.target.src);
            }
        });
    }

    /**
     * Thi·∫øt l·∫≠p Livewire listeners
     */
    setupLivewireListeners() {
        if (!window.Livewire) return;

        // Listen for Livewire events
        window.Livewire.on('scroll-to-bottom', () => {
            // console.log('üí¨ ChatRealtime: Received scroll-to-bottom event');
            this.scrollToBottom();
        });

        window.Livewire.on('message-sent', () => {
            // console.log('üí¨ ChatRealtime: Received message-sent event');
            this.handleMessageSent();
        });

        window.Livewire.on('conversation-changed', (data) => {
            console.log('üí¨ ChatRealtime: Received conversation-changed event', data);
            this.handleConversationChange(data[0]);
        });

        window.Livewire.on('file-uploaded', () => {
            // console.log('üí¨ ChatRealtime: Received file-uploaded event');
            this.handleFileUploaded();
        });

        // Listen for Livewire updates v√† auto scroll nh∆∞ chat.js
        document.addEventListener('livewire:updated', () => {
            // console.log('üí¨ ChatRealtime: Livewire updated, auto-scrolling');
            // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ DOM c·∫≠p nh·∫≠t xong
            setTimeout(() => {
                this.scrollToBottom();
            }, 50);
        });

        // Listen for message updates specifically
        document.addEventListener('livewire:updated.message-container', () => {
            // console.log('üí¨ ChatRealtime: Message container updated');
            this.scrollToBottom();
        });

        // console.log('üí¨ ChatRealtime: Livewire listeners setup completed');
    }

    /**
     * G·ª≠i tin nh·∫Øn
     */
    sendMessage() {
        if (!this.messageInput) {
            console.error('üí¨ ChatRealtime: Message input not found');
            return;
        }

        const content = this.messageInput.value.trim();
        if (!content) {
            console.warn('üí¨ ChatRealtime: Empty message content');
            return;
        }

        // console.log('üí¨ ChatRealtime: Sending message via Livewire', {
        //     content: content,
        //     inputElement: this.messageInput.id || 'no-id'
        // });

        // Clear input ngay l·∫≠p t·ª©c ƒë·ªÉ tr√°nh g·ª≠i tr√πng nh∆∞ chat.js
        this.messageInput.value = '';

        // G·ªçi Livewire method
        if (window.Livewire) {
            try {
                const component = window.Livewire.find(this.findChatRealtimeComponentId());
                if (component) {
                    // Set v√† call method
                    component.set('message_content', content);
                    component.call('sendMessage');
                } else {
                    // Fallback: dispatch event
                    window.Livewire.dispatch('sendMessage', { message_content: content });
                    console.warn('üí¨ ChatRealtime: Used fallback dispatch method');
                }
            } catch (error) {
                console.error('üí¨ ChatRealtime: Error sending message:', error);
                // Kh√¥i ph·ª•c n·ªôi dung n·∫øu c√≥ l·ªói
                this.messageInput.value = content;
            }
        } else {
            console.error('üí¨ ChatRealtime: Livewire not available');
            // Kh√¥i ph·ª•c n·ªôi dung n·∫øu Livewire kh√¥ng c√≥
            this.messageInput.value = content;
        }
    }

    /**
     * X·ª≠ l√Ω typing indicator
     */
    handleTyping() {
        if (this.isTyping) return;

        this.isTyping = true;
        
        // Broadcast typing event
        if (window.Echo && this.currentConversationId) {
            // Implementation s·∫Ω c·∫ßn backend support
        }

        // Reset typing sau 3 gi√¢y
        clearTimeout(this.typingTimeout);
        this.typingTimeout = setTimeout(() => {
            this.isTyping = false;
        }, 3000);
    }

    /**
     * X·ª≠ l√Ω paste (cho h√¨nh ·∫£nh)
     */
    handlePaste(e) {
        const items = e.clipboardData.items;
        
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                e.preventDefault();
                const file = item.getAsFile();
                this.handleFileUpload(file);
                break;
            }
        }
    }

    /**
     * X·ª≠ l√Ω file upload
     */
    handleFileUpload(file) {
        console.log('üí¨ ChatRealtime: Handling file upload', {
            name: file.name,
            type: file.type,
            size: file.size
        });

        // Validation
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            this.showToast('File qu√° l·ªõn (t·ªëi ƒëa 10MB)', 'error');
            return;
        }

        // Set file to Livewire component
        if (window.Livewire && this.fileUploadInput) {
            try {
                // Trigger Livewire file upload
                const component = window.Livewire.find(this.findChatRealtimeComponentId());
                if (component) {
                    // Livewire s·∫Ω handle file upload
                    this.fileUploadInput.files = [file];
                    this.fileUploadInput.dispatchEvent(new Event('change'));
                }
            } catch (error) {
                console.error('üí¨ ChatRealtime: Error uploading file:', error);
                this.showToast('L·ªói khi upload file', 'error');
            }
        }
    }

    /**
     * Scroll to bottom c·ªßa chat
     */
    scrollToBottom() {
        if (this.chatConversation) {
            // console.log('üí¨ ChatRealtime: Scrolling to bottom', {
            //     scrollHeight: this.chatConversation.scrollHeight,
            //     scrollTop: this.chatConversation.scrollTop,
            //     clientHeight: this.chatConversation.clientHeight
            // });

            // Method t·ª´ chat.js - Direct assignment
            this.chatConversation.scrollTop = this.chatConversation.scrollHeight;
            
            // console.log('üí¨ ChatRealtime: Scroll completed', {
            //     newScrollTop: this.chatConversation.scrollTop,
            //     scrollHeight: this.chatConversation.scrollHeight
            // });
        } else {
            console.warn('üí¨ ChatRealtime: Chat conversation element not found for scrolling');
        }
    }

    /**
     * Copy tin nh·∫Øn
     */
    copyMessage(message) {
        navigator.clipboard.writeText(message).then(() => {
            this.showCopyAlert();
        }).catch(err => {
            console.error('üí¨ ChatRealtime: Could not copy message:', err);
        });
    }

    /**
     * Show copy alert
     */
    showCopyAlert() {
        const alert = document.getElementById('copyClipBoard');
        if (alert) {
            alert.style.display = 'block';
            setTimeout(() => {
                alert.style.display = 'none';
            }, 2000);
        }
    }

    /**
     * Show image modal
     */
    showImageModal(imageSrc) {
        const modal = document.getElementById('imageModal');
        if (modal) {
            const modalBody = modal.querySelector('.modal-content');
            modalBody.innerHTML = `
                <div class="modal-header">
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center">
                    <img src="${imageSrc}" class="img-fluid" alt="Image">
                </div>
            `;
            
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
        }
    }

    // /**
    //  * Show toast notification
    //  */
    // showToast(message, type = 'info') {
    //     if (window.toastr) {
    //         toastr[type](message);
    //     } else {
    //         console.log(`üí¨ ChatRealtime: ${type.toUpperCase()}: ${message}`);
    //     }
    // }

    /**
     * Show message notification
     */
    showMessageNotification(data) {
        // C√≥ th·ªÉ implement browser notification ·ªü ƒë√¢y
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(`Tin nh·∫Øn m·ªõi t·ª´ ${data.sender?.name || 'Unknown'}`, {
                body: data.content,
                icon: '/favicon.ico'
            });
        }
    }

    /**
     * Update user status UI
     */
    updateUserStatus(user) {
        if (!user) return;

        // Update conversation list status indicators
        const conversationItem = document.querySelector(`[data-user-id="${user.id}"]`);
        if (conversationItem) {
            const statusIndicator = conversationItem.querySelector('.status-indicator');
            if (statusIndicator) {
                statusIndicator.className = `status-indicator ${user.status === 'online' ? 'online' : 'offline'}`;
            }
        }
    }

    /**
     * Refresh conversation list
     */
    refreshConversationList() {
        if (window.Livewire) {
            // Dispatch event to ConversationList component
            window.Livewire.dispatch('refreshConversations');
        }
    }

    /**
     * Handle conversation change
     */
    handleConversationChange(conversationId) {
        console.log('üí¨ ChatRealtime: Conversation changed to', conversationId);
        
        // Update current conversation
        this.setupConversationChannel(conversationId);
        
        // Update global variable
        window.currentConversationId = conversationId;
        
        // Scroll to bottom
        setTimeout(() => this.scrollToBottom(), 200);
    }

    /**
     * Handle message sent
     */
    handleMessageSent() {
        // console.log('üí¨ ChatRealtime: Message sent successfully');
        
        // Force clear input multiple ways
        if (this.messageInput) {
            this.messageInput.value = '';
            this.messageInput.dispatchEvent(new Event('input')); // Trigger any input listeners
        }

        // Also clear Livewire model
        if (window.Livewire) {
            try {
                const component = window.Livewire.find(this.findChatRealtimeComponentId());
                if (component) {
                    component.set('message_content', '');
                }
            } catch (error) {
                console.warn('üí¨ ChatRealtime: Could not clear Livewire model:', error);
            }
        }
        
        // Scroll to bottom v·ªõi ƒë·ªô tr·ªÖ ƒë·ªÉ ƒë·∫£m b·∫£o DOM ƒë√£ c·∫≠p nh·∫≠t
        setTimeout(() => {
            this.scrollToBottom();
        }, 100);
        
        // Show feedback
        // this.showToast('Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i', 'success');
    }

    /**
     * Handle file uploaded
     */
    handleFileUploaded() {
        console.log('üí¨ ChatRealtime: File uploaded successfully');
        
        // Clear file input
        if (this.fileUploadInput) {
            this.fileUploadInput.value = '';
        }
        
        // Scroll to bottom
        this.scrollToBottom();
        
        // Show feedback
        this.showToast('File ƒë√£ ƒë∆∞·ª£c g·ª≠i', 'success');
    }

    /**
     * Find ChatRealtime Livewire component ID
     */
    findChatRealtimeComponentId() {
        // Method 1: T√¨m element c√≥ wire:id trong chat content
        const chatElements = document.querySelectorAll('[wire\\:id]');
        for (let element of chatElements) {
            const wireId = element.getAttribute('wire:id');
            if (wireId) {
                console.log('üí¨ ChatRealtime: Found Livewire component', wireId);
                return wireId;
            }
        }

        // Method 2: T√¨m component qua Livewire.all()
        if (window.Livewire && window.Livewire.all) {
            const components = window.Livewire.all();
            // console.log('üí¨ ChatRealtime: Available Livewire components:', components.length);
            
            for (let component of components) {
                // Ki·ªÉm tra n·∫øu component c√≥ method c·∫ßn thi·∫øt
                if (component.name && component.name.includes('ChatRealtime')) {
                    console.log('üí¨ ChatRealtime: Found ChatRealtime component by name', component.id);
                    return component.id;
                }
            }
            
            // Fallback: l·∫•y component ƒë·∫ßu ti√™n
            if (components.length > 0) {
                console.log('üí¨ ChatRealtime: Using first available component', components[0].id);
                return components[0].id;
            }
        }

        console.warn('üí¨ ChatRealtime: No Livewire component found');
        return null;
    }

    /**
     * Switch to conversation
     */
    switchConversation(conversationId) {
        // console.log('üí¨ ChatRealtime: Switching to conversation', conversationId);
        
        if (window.Livewire) {
            const component = window.Livewire.find(this.findChatRealtimeComponentId());
            if (component) {
                component.call('switchConversation', conversationId);
            }
        }
        
        this.handleConversationChange(conversationId);
    }

    /**
     * Debug method ƒë·ªÉ ki·ªÉm tra callbacks
     */
    debugChannelCallbacks() {
        if (!window.Echo || !window.Echo.connector || !window.Echo.connector.pusher) {
            console.error('üí¨ ChatRealtime: Pusher not available for debugging');
            return;
        }

        const pusher = window.Echo.connector.pusher;
        const channels = pusher.channels.channels;
        
        // console.log('üí¨ ChatRealtime: Debugging channel callbacks');
        
        Object.keys(channels).forEach(channelName => {
            const channel = channels[channelName];
            console.log(`üí¨ ChatRealtime: Channel ${channelName}:`, {
                callbacks: channel.callbacks,
                MessageSent: channel.callbacks['MessageSent'] || 'NO CALLBACKS'
            });
        });
    }

    /**
     * Force re-setup callbacks n·∫øu b·ªã m·∫•t
     */
    forceSetupCallbacks() {
        if (!this.currentConversationId) {
            console.warn('üí¨ ChatRealtime: No conversation ID to setup callbacks');
            return;
        }

        // console.log('üí¨ ChatRealtime: Force re-setting up callbacks');
        
        // Re-setup conversation channels
        this.setupConversationChannel(this.currentConversationId);
        
        // Re-setup global channels
        this.setupGlobalChannels();
    }

    /**
     * Cleanup when destroying
     */
    destroy() {
        // console.log('üí¨ ChatRealtime: Cleaning up...');
        
        // Leave all channels
        this.echoChannels.forEach((channel, channelName) => {
            try {
                window.Echo.leave(channelName);
            } catch (error) {
                console.error(`üí¨ ChatRealtime: Error leaving ${channelName}:`, error);
            }
        });
        
        this.echoChannels.clear();
        
        // Clear timeouts
        if (this.typingTimeout) {
            clearTimeout(this.typingTimeout);
        }
    }
}

// Global functions for backward compatibility
window.handleEnterKey = function(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        
        if (window.chatRealtime) {
            window.chatRealtime.sendMessage();
        }
    }
};

window.switchConversation = function(conversationId) {
    if (window.chatRealtime) {
        window.chatRealtime.switchConversation(conversationId);
    }
};

// Initialize chat realtime when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        // console.log('üí¨ ChatRealtime: DOM ready, initializing...');
        
        // Debug: Check available elements
        console.log('üí¨ ChatRealtime: Available elements check:', {
            messageInputField: !!document.getElementById('messageInputField'),
            wireModelInput: !!document.querySelector('[wire\\:model="message_content"]'),
            chatConversation: !!document.getElementById('chat-conversation'),
            messageContainer: !!document.getElementById('message-container'),
            currentConversationId: window.currentConversationId,
            livewireAvailable: !!window.Livewire,
            echoAvailable: !!window.Echo
        });
        
        window.chatRealtime = new ChatRealtime();
    });
} else {
    // DOM already loaded
    console.log('üí¨ ChatRealtime: DOM already loaded, initializing immediately...');
    window.chatRealtime = new ChatRealtime();
}

// Also initialize when Livewire is loaded (if not already)
document.addEventListener('livewire:initialized', function() {
    // console.log('üí¨ ChatRealtime: Livewire initialized');
    if (!window.chatRealtime) {
        console.log('üí¨ ChatRealtime: Creating instance after Livewire init');
        window.chatRealtime = new ChatRealtime();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window.chatRealtime) {
        window.chatRealtime.destroy();
    }
});

console.log('üí¨ ChatRealtime: Module loaded successfully');